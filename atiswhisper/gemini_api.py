from tqdm import tqdm
import os
import re
from typing import List, Any

def generate_prompt(srts: List[str], transcripts: List[str]) -> str:
    """
    Generates a prompt for the Gemini API to correct SRT transcripts using the provided correct transcripts.

    Args:
        srts (List[str]): List of SRT transcript strings (with timestamps).
        transcripts (List[str]): List of correct transcript strings (without timestamps).

    Returns:
        str: The formatted prompt string for the Gemini API.
    """
    assert len(srts) == len(transcripts), "Mismatch: Number of SRT files does not match number of transcript files."

    prompt = "You are given multiple pairs of items. Each pair consists of:\n" \
             "1. An .srt transcript (enclosed in <srt_i></srt_i>) generated by Whisper, which may contain transcription errors.\n" \
             "2. The correct transcript (enclosed in <transcript_i></transcript_i>), without timestamps.\n\n" \
             "**Task:**\n" \
             "For each pair, correct the text in the .srt transcript using the correct transcript, but keep the original timestamps and formatting unchanged.\n" \
             "Return ONLY the corrected .srt transcripts, each enclosed in <corrected_srt_i></corrected_srt_i> tags, with no extra commentary or formatting.\n\n"

    for idx, (srt, transcript) in enumerate(zip(srts, transcripts)):
        prompt += f"<srt_{idx}>{srt}</srt_{idx}>\n\n"
        prompt += f"<transcript_{idx}>{transcript}</transcript_{idx}>\n\n"

    return prompt

def process_response(response: Any) -> List[str]:
    """
    Extracts all corrected SRT transcripts from the Gemini API response.

    Args:
        response (Any): The response object from the Gemini API. Must have a 'text' attribute.

    Returns:
        List[str]: List of corrected SRT transcript strings.
    """
    pattern = r"<corrected_srt_\d+>(.*?)</corrected_srt_\d+>"
    matches = re.findall(pattern, response.text, re.DOTALL)
    return matches

def correct_srts(
    gemini_client: Any,
    srt_dir: str,
    transcript_dir: str,
    corrected_srt_dir: str,
) -> None:
    """
    Processes batches of SRT and transcript files, sends them to the Gemini API for correction,
    and writes the corrected SRTs to the output directory.

    Args:
        gemini_client (Any): The Gemini API client instance.
        srt_dir (str): Directory containing the original SRT files.
        transcript_dir (str): Directory containing the correct transcript files.
        corrected_srt_dir (str): Directory to save the corrected SRT files.

    Returns:
        None
    """
    os.makedirs(corrected_srt_dir, exist_ok=True)

    batch_size = 5
    srt_files = sorted([f for f in os.listdir(srt_dir) if f.endswith('.srt')], key=lambda x: int(x.split('.')[0]))
    num_files = len(srt_files)
    num_batches = (num_files + batch_size - 1) // batch_size

    for batch_num in tqdm(range(num_batches), desc=f"Correcting transcripts with batch size {batch_size}"):
        srts: List[str] = []
        transcripts: List[str] = []
        start = batch_num * batch_size
        end = min(start + batch_size, num_files)
        for i in range(start, end):
            fp_srt = os.path.join(srt_dir, f"{i}.srt")
            fp_transcript = os.path.join(transcript_dir, f"{i}.txt")
            with open(fp_srt) as f:
                srt = f.read()
            with open(fp_transcript) as f:
                transcript = f.read()
            srts.append(srt)
            transcripts.append(transcript)

        prompt = generate_prompt(srts, transcripts)
        response = gemini_client.generate_content(prompt)
        corrected_srts = process_response(response)
        for srt_id, srt in enumerate(corrected_srts):
            with open(os.path.join(corrected_srt_dir, f"{start + srt_id}.srt"), "w") as f:
                f.write(srt)
